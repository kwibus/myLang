4 possibility: left to right/right to left , top down / bottom up

Bottom up
    you can assume variable is defined and define them latter, but you don't now its name are location so you need absolute names, or second pass to replace names
    if you add a apply to the top you have to generate  a left or right term top down anyway
    and you can't specify the final type
    so no

top down
    know already defined variables, because lambda before variable
        simple
        smallcheck compatible
        can  generate every type if following typing rules
    size:
        you should be able to generate  terms of every size and type
        this not alleyways possible there is no term of type Double  of size 2 or a -> b -> c -> d of size 1 if there is no such type in the env

        this can be solved with backtracking. This is not a problem if problemmatic condition are detect early
            (not yet. Apply (term 100 t1)(term 1 t2))
            you can pre calculate terms with low size with smallcheck and do a lookup so you can detect problem early, (no can't no precomputer env)
                this can become problematic is the language grows
                you still have to use quickcheck for the inhale tens values
                is this faster?
            you can calculate the smallest first so problem are detect early ? (left to right or)
            you can limit function type size. Real world programs rarely have  types with more than 7 args
            you can limit the number of different try add a node. So if you haven 100 possibility's to chose from  you try only 10
                this has the down side that if a correct (size and type) term exist you are not guarantied to find one

        if you want to backtrack you should prevent to make the same choise twise. so you have to remember every choice or the alternatives
        the alternatives is easy to implement but requires much memory if its never revisit.
        Remembering every choice requires less initially memory but is slow and memory intensive if you have to revisit node often
        backtracking id only feasible if you don't have to revisit to often 

        you can redefine size to something so that every size and type guaranties to exist.
        The new size should have the property that there a finit numer of terms of that size, and all could be generated
            depthe?

        you can insert dummy variable for terms that cant be found
        you con weaken the restrict of defined size to, to  allow size 2 if size 1 does not exist
        look at where the generator  spend most of time trying, and try to find a cut

    how to choose type
    you can choose type at random, need more backtracking, get always monomorfic types
    use var and unify, unify expensive? Can generate strange types and complicated (this is also a plus, because you find bugs with rarely used terms)
    and var can grow. so in (Apply (e2::a ->b) e2::a) a can grow and maybe e2 can generate a term of that type
        solution:: pre calculate  max tsize of a so you can cut early
                   this is only useful for a not for a -> b
                   and because you have a env to consider, if there is a variable partial compatible with a you can genarate bigger a then expexted
        solution:: calculate a before a-> b
How to debug
    if you insert dummy at mzero you can find where it get stuck
    how to detect speedup. because undetermenistic


Assumption problematic terms occur near the leafs. The distance to the leafs is proportional to the size of the goal type
    backtracking is needed if you can not find a term of a specific size and type
    1)if you can generate a term with type t of size n you can generate a term of size m> n of type t (proof?)  wrong
    2)the size of your type is proportional to the minimum size of your term with the same type when you ignore initial env (proof?)
    leafs have a small size. (definition)
   
    from 2 follows that a problem occur can occur if size type is bigger than size term
    because backtracking try every option until success. and from 1 2 follows that you can alleyways generate a term of type t size n if size t < n
    so from this follows that you backtracking further than n


